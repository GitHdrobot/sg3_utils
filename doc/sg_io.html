<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Linux SG_IO ioctl in the 2.6 series</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="keywords" content="Linux, SCSI, SG_IO, ioctl">
  <meta name="GENERATOR"
 content="Mozilla/4.79 [en] (X11; U; Linux 2.5.31 i686) [Netscape]">
</head>
<body alink="#ff0000" background="paper.jpg" bgcolor="#ffffff"
 link="#0000ff" text="#000000" vlink="#000080">
<center>
<h1><a class="mozTocH1" name="mozTocId288504"></a> The&nbsp; Linux
SG_IO ioctl in the 2.6 series<br>
</h1>
</center>
<a href="#Conclusion"></a>
<ol id="mozToc">
<!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6--><li><a href="#mozTocId288504">
The&nbsp; Linux
SG_IO ioctl in the 2.6 series </a>
    <ol>
      <li><a href="#mozTocId857690">Introduction</a></li>
      <li><a href="#mozTocId844428">SCSI and related
command sets </a></li>
      <li><a href="#mozTocId568229">SG_IO ioctl overview</a></li>
      <li><a href="#mozTocId575826">SG_IO ioctl in the sg
driver </a></li>
      <li><a href="#mozTocId104192">SG_IO ioctl
differences </a></li>
      <li><a href="#mozTocId830340">open() considerations</a></li>
      <li><a href="#mozTocId645134">SCSI command
permissions</a></li>
      <li><a href="#mozTocId154063">Maximum transfer size per command</a></li>
      <li><a href="#mozTocId267334">Conclusion</a></li>
    </ol>
  </li>
</ol>
<h2><a class="mozTocH2" name="mozTocId857690"></a>Introduction</h2>
The <span style="font-weight: bold;">SG_IO</span> ioctl permits user
applications to send SCSI commands to a device. In the linux 2.4 series
this ioctl was only available via the SCSI generic (sg) driver. In the
linux 2.6 series the SG_IO ioctl is additionally available for block
devices
and SCSI tape (st) devices.&nbsp; So there are multiple implementations
of this ioctl within the kernel with slightly different characteristics
and describing these is the purpose of this document.<br>
<br>
The information in this page is valid for linux kernel 2.6.16 .<br>
<h2><a class="mozTocH2" name="mozTocId844428"></a>SCSI and related
command sets<br>
</h2>
All SCSI devices should respond to an INQUIRY command and part of their
response is the so-called peripheral device type. This is used by the
linux kernel to decide which upper level driver controls the device.
There are also devices that belong to other (i.e. not considered SCSI)
transports that use SCSI command sets, the primary examples of this are
(S-)ATAPI CD and DVD drives. Not all peripheral device types map to
upper level drivers and devices of these types are usually accessed via
the SCSI generic (sg) driver.<br>
<br>
SCSI (draft) standards are found at <a href="http://www.t10.org/">www.t10.org</a>
. SCSI commands common to all
SCSI devices are found in SPC-4 while those specific to block devices
are found in SBC-2, those for CD/DVD drives are found in MMC-5 and
those for SCSI tape drives are found in SSC-3.<br>
<br>
The major non-SCSI command set in the storage area is for ATA
<span style="font-style: italic;">non-packet</span> devices which are
typically disks. ATA <span style="font-style: italic;">packet</span>
devices use ATAPI which in
the vast majority of cases carry a SCSI command set. The most recent
draft ATA command set standard is ATA8-ACS and can be found at <a
 href="http://www.t13.org/">www.t13.org</a> . To complicate things
(non-packet) ATA devices may have their native command set translated
into SCSI. This can happen in the kernel (e.g. libata in linux) or in
an intermediate device (e.g. in a USB external disk enclosure). Yet
another possibility are disks
whose firmware can be changed to allow them to use either the SCSI or
ATA command set, this may happen in the SAS/SATA area since the
physical (cabling) and phy (electrical signalling) levels are so
similar.<br>
<h2><a class="mozTocH2" name="mozTocId568229"></a>SG_IO ioctl overview</h2>
The third argument given to the SG_IO ioctl is a pointer to an instance
of the sg_io_hdr structure which is defined in the &lt;scsi/sg.h&gt;
header file. The execution of the SG_IO ioctl can viewed as going
through three phases:<br>
<ol>
  <li>do sanity checks on the metadata in the sg_io_hdr instance; read
the input fields and the data pointed to by some of those fields; build
a SCSI command and issue it to the device</li>
  <li>wait for either a response from the device, the command to
timeout or
the user to terminate the process (or thread) that invoked the SG_IO
ioctl</li>
  <li>write the output fields and in some cases write data to locations
pointed to by some fields, then return</li>
</ol>
Only phase 1 returns an ioctl error (i.e. a return value of -1 and a
value
set in errno). In phase 2, command timeouts should be used sparingly as
the device (and some others on the same interconnect) may end up being
reset. If the user terminates the process or thread that invoked the
SG_IO ioctl then obviously phase 3 never occurs but the command
execution runs to completion (or timeout) and the kernel "throws away"
the results. If the command yields a SCSI status of CHECK
CONDITION (in field "status") then sense data is written out in
phase 3 .<br>
<br>
Now we will assume that the SCSI command involves user data being
transferred to or from the device. The SCSI subsystem does not support
true bidirectional data transfers to a device. All data DMA transfers
(assuming the hardware supports DMA) occur in phase 2. However, if
indirect IO is being used (i.e. neither direct IO nor mmap-ed
transfers) then either:<br>
<ul>
  <li>data is read from the user space in phase 1 into kernel buffers
and DMA-ed to the device in phase 2, or</li>
  <li>data is read from the device into kernel buffers in phase 2 and
written into the user space in phase 3</li>
</ul>
When direct IO or mmap-ed transfers are being used then all user data
is moved in phase 2 . If a process is terminated during such a data
transfer then the kernel gracefully handles this (by pinning the
associated memory pages until the transfer is complete).<br>
<br>
The sg_io_hdr structure has 22 fields (members) but typically only a
small number of them need to be set. The following code fragment shows
the setup for a simple TEST UNIT READY SCSI command which has no
associated data transfers:<br>
&nbsp;&nbsp;&nbsp; <br>
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; unsigned char
sense_b[32];</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; unsigned char
turCmbBlk[] = {TUR_CMD, 0, 0, 0, 0, 0};<br>
&nbsp;&nbsp;&nbsp; struct sg_io_hdr io_hdr;<br
 style="font-family: monospace;">
</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
memset(&amp;io_hdr, 0, sizeof(struct sg_io_hdr));</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
io_hdr.interface_id = 'S';</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; io_hdr.cmd_len
= sizeof(turCmbBlk);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
io_hdr.mx_sb_len = sizeof(sense_b);</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
io_hdr.dxfer_direction = SG_DXFER_NONE;</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; io_hdr.cmdp =
turCmbBlk;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; io_hdr.sbp =
sense_b;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; io_hdr.timeout
= DEF_TIMEOUT;</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; if (ioctl(fd,
SG_IO, &amp;io_hdr) &lt; 0) {</span><br>
<br>
The memset() call is pretty important, setting unused input fields to
safe values. Setting the timeout field to zero is not a good idea;
30,000 (for 30 seconds) is a reasonable default for most SCSI commands.
As always, good error
processing consumes a lot more code. This is especially the case with
SCSI commands that yield "sense data" when something goes wrong. For
example, if there is a medium error during a disk read, the sense data
will contain the logical block address (lba) of the failure. Another
error processing example is a SCSI command that the device considers an
"illegal
request", the sense data may show the byte and bit position of the
field in the command block (usually referred to as a "cdb") that it
objects to. For examples on error processing please refer to the
sg3_utils package, its "examples" directory and its library components:
sg_lib.c (SCSI error processing and tables) and sg_cmds.c (common SCSI
commands).<br>
<br>
Below is a grouping of important sg_io_hdr structure fields with brief
summaries:<br>
Command block (historically referred to as the "cdb"):<br>
<ul>
  <li>cmdp - pointer to cdb (the SCSI command block)</li>
  <li>cmd_len - length (in bytes) of cdb</li>
</ul>
Data transfer:<br>
<ul>
  <li>dxferp - pointer to user data to start reading from or start
writing to</li>
  <li>dxfer_len - number of bytes to transfer</li>
  <li>dxfer_direction - whether to read from device (into user memory)
or write to device (from user memory) or transfer no data:
DXFER_FROM_DEV, DXFER_TO_DEV or DXFER_NONE respectively<br>
  </li>
  <li>resid - requested number of bytes to transfer (i.e. dxfer_len)
less the actual number transferred</li>
</ul>
Error indication:<br>
<ul>
  <li>status - SCSI status returned from the device</li>
  <li>host_status - error from Host Bus Adapter including initiator
(port)<br>
  </li>
  <li>driver_status - driver (mid level or low level driver) error and
suggestion mask</li>
</ul>
Sense data (only used when 'status' is CHECK CONDITION or
(driver_status &amp; DRIVER_SENSE) is true):<br>
<ul>
  <li>sbp - pointer to start writing sense data to<br>
  </li>
  <li>mx_sb_len - maximum number of bytes to write to sbp</li>
  <li>sb_len_wr - actual number of bytes written to sbp</li>
</ul>
The fields in the sg_io_hdr structure are defined in more detail in the
<a href="http://www.tldp.org/HOWTO/SCSI-Generic-HOWTO/index.html">SCSI-Generic-HOWTO</a>
document.<br>
<h2><a class="mozTocH2" name="mozTocId575826"></a>SG_IO ioctl in the sg
driver<br>
</h2>
Linux kernel 2.4.0 was the first production kernel in which the SG_IO
ioctl appeared in the SCSI generic (sg) driver. The sg driver itself
has been in linux since around 1993.
An instance of the sg_io_hdr structure in the sg driver can either be:<br>
<ul>
  <li>pointed to by the third argument of the SG_IO ioctl</li>
  <li>pointed to by the second argument of UNIX write() or read()
system
calls which have a file descriptor of a sg device node as their first
argument<br>
  </li>
</ul>
The <a href="http://www.tldp.org/HOWTO/SCSI-Generic-HOWTO/index.html">SCSI-Generic-HOWTO</a>
document describes the sg driver in the lk 2.4 series including its use
of the SG_IO ioctl. Prior to the lk 2.4 series the sg driver only had
the sg_header structure. It was used as an asynchronous
command interface in which command, metadata and optionally user data
was sent via a Unix write() system call. The corresponding response
which included
error information (e.g. sense data) or optionally user data was
received via a Unix read() system call. Two major additions were made
to the sg
driver at the beginning of the lk 2.4 series:<br>
<ul>
  <li>a new metadata structure (sg_io_hdr) as an alternative to the
original mixed metadata and data structure (sg_header)</li>
  <li>the SG_IO ioctl that used the new metadata structure and was
synchronous: it sent a SCSI command and waited for its reply</li>
</ul>
The sg_io_hdr only contains metadata in the sense that it contains
pointers to locations of where data will come from (command or data in)
or go to (sense data or data out). These pointers have caused problems
in mixed 32/64 bit environments, especially when the user application
(e.g. cdrecord) is built for 32 bits and the kernel is 64 bits. The lk
2.6 series has a compatibility layer to cope with this via code
specialized for the SG_IO ioctl. Unfortunately this problem was not
foreseen when the sg_io_hdr structure was designed.<br>
<br>
A significant feature of the SG_IO ioctl in the sg driver is that it
is user interruptible. This means between issuing a command (e.g. a
long duration command like a disk format) and its response arriving a
user could hit control-C on the associated application. The kernel
would remain stable and resources would be cleared up at the
appropriate time. The sg driver does not attempt to abort such a
command that is "in flight", it simply throws away the response and
cleans up. Naturally the user has no direct way of finding out whether
an interrupted command succeeded or not, by there may be indirect ways.<br>
<br>
A warning may also be in order here: a long duration command such as
format would typically be given a long timeout value. If the user
interrupted the application that sent the format command then the
device may remain
busy doing the format (especially if the IMMED bit is not set). So if
the user then sent a short duration command such as TEST UNIT READY or
REQUEST SENSE to see what the device was doing, these commands may
timeout. This would invoke the SCSI subsystem error handler which would
most likely
send a device reset, thus aborting the format, to get the device's
attention. This is probably not what the user had in mind!<br>
<br>
<h2><a class="mozTocH2" name="mozTocId104192"></a>SG_IO ioctl
differences<br>
</h2>
In the following table,
sg_io_hdr structure fields are listed in the order they appear in that
structure. Basically the "in" fields appear at the top of the structure
and are read in phase 1. The latter fields are termed as "out" and are
written by the SG_IO implementation in phase 3.<br>
&nbsp;<br>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <caption><span style="font-weight: bold;">Table 1. sg_io_hdr
structure&nbsp; summary and implementation differences</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">sg_io_hdr
field</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">in
or out</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">type</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">different</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">brief
description including differences between implementations</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">interface_id<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">int<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">guard field. Current
implementations only accept " (int)'S' ". If not set, the sg driver
sets errno to ENOSYS
while the block layer sets it to EINVAL<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">dxfer_direction<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">(-ve) int<br>
      </td>
      <td style="vertical-align: top;">minor<br>
      </td>
      <td style="vertical-align: top;">direction of data transfer.
SG_DXFER_NONE and friends are defined as negative integers so the sg
driver can discriminate between sg_io_hdr instances and those of
sg_header. This nuance is irrelevant to non-sg driver usage of SG_IO.
See below.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cmd_len<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">unsigned char<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">limits command length to 255
bytes. No SCSI commands (even variable length ones in OSD) are this
long (yet)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">max_sb_len<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">unsigned char<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">maximum number of bytes of sense
data that the driver can output via the sbp pointer<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">iovec_count<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">unsigned short<br>
      </td>
      <td style="vertical-align: top;">yes<br>
      </td>
      <td style="vertical-align: top;">if not sg driver and greater
than zero then the SG_IO ioctl fails with errno set to EOPNOTSUPP; sg
driver treats dxferp as a pointer to an array struct sg_iovec when this
field is greater than zero<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">dxfer_len<br>
      </td>
      <td style="vertical-align: top;">in<br>
      <br>
      </td>
      <td style="vertical-align: top;">unsigned int<br>
      </td>
      <td style="vertical-align: top;">minor<br>
      </td>
      <td style="vertical-align: top;">number of bytes of data to
transfer to or from the device. Upper limit for block devices related
to <span style="font-family: monospace;">/sys/block/&lt;device&gt;/queue/max_sectors_kb</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">dxferp </td>
      <td style="vertical-align: top;">in [*in or *out]<br>
      </td>
      <td style="vertical-align: top;">void *<br>
      </td>
      <td style="vertical-align: top;">minor<br>
      </td>
      <td style="vertical-align: top;">pointer to (user space) data to
transfer to (if reading from device) or transfer from (if writing to
device). Further level of indirection in the sg driver when iovec_count
is greater than 0 .<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cmdp </td>
      <td style="vertical-align: top;">in [*in]<br>
      </td>
      <td style="vertical-align: top;">unsigned char *<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">pointer to SCSI command. The
SG_IO ioctl in the sg drive fails with errno set to&nbsp; EMSGSIZE if
cmdp is NULL and EFAULT if it is invalid; the block layer sets errno to
EFAULT&nbsp; in both cases.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">sbp<br>
      </td>
      <td style="vertical-align: top;">in [*out]<br>
      </td>
      <td style="vertical-align: top;">unsigned char *<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">pointer to user data area where
no more than max_sb_len bytes of sense data from the device will be
written if the SCSI status is CHECK CONDITION. <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">timeout<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">unsigned int<br>
      </td>
      <td style="vertical-align: top;">yes <br>
(if = 0)<br>
      </td>
      <td style="vertical-align: top;">time in milliseconds that the
SCSI mid-level will wait for a response. If that timer expires
before the command finishes, then the command may be aborted, the
device (and maybe others on the same interconnect) may be reset
depending on error
handler settings. Dangerous stuff, the SG_IO ioctl has no control
(through this interface) of exactly what happens. In the sg driver a
timeout value of 0 means 0 milliseconds, in the block layer (currently)
it means 60 seconds.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">flags<br>
      </td>
      <td style="vertical-align: top;">in<br>
      </td>
      <td style="vertical-align: top;">unsigned int<br>
      </td>
      <td style="vertical-align: top;">yes<br>
      </td>
      <td style="vertical-align: top;">Block layer SG_IO ioctl ignores
this field; the sg driver uses it to request special services like
direct IO or mmap-ed transfers. It is a bit mask.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">pack_id<br>
      </td>
      <td style="vertical-align: top;">in -&gt; out<br>
      </td>
      <td style="vertical-align: top;">int<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">unused (for user space program
tag)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">usr_ptr<br>
      </td>
      <td style="vertical-align: top;">in -&gt; out<br>
      </td>
      <td style="vertical-align: top;">void *<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">unused (for user space pointer
tag)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">status<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned char<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">SCSI command status, zero
implies GOOD<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">masked_status<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned char<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Logically: masked_status ==
((status &amp; 0x3e) &gt;&gt; 1). Old linux SCSI subsystem usage,
deprecated. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">msg_status<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned char<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">SCSI parallel interface (SPI)
message status (very
old, deprecated)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">sb_len_wr<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned char<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">actual length of sense data (in
bytes) output via sbp pointer.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">host_status<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned short<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">error reported by the initiator
(port). These are the "DID_*" error codes in scsi.h<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">driver_status<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned short<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">bit mask: error and suggestion
reported by the low level driver (LLD). These are the "DRIVER_*" error
codes in scsi.h</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">resid<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">int<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">(dxfer_len -
number_of_bytes_actually_transferred). Typically only set when there is
a shortened DMA transfer from the device.&nbsp; Not necessarily an
error. Older LLDs always yield zero.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">duration<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned int<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">number of milliseconds that
elapsed between when the command was injected into the SCSI mid level
and the corresponding "done" callback was invoked. Roughly the duration
of the SCSI command in milliseconds.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">info<br>
      </td>
      <td style="vertical-align: top;">out<br>
      </td>
      <td style="vertical-align: top;">unsigned int<br>
      </td>
      <td style="vertical-align: top;">minor<br>
      </td>
      <td style="vertical-align: top;">bit mask indicating what was
done (or not) and whether any error was detected. Block layer SG_IO
ioctl only sets SG_INFO_CHECK if an error was detected<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
The DID_* and DRIVER_* error and suggestion codes (associated with
host_status and driver_status) are discussed in more detail in the
<a href="http://www.tldp.org/HOWTO/SCSI-Generic-HOWTO/index.html">SCSI-Generic-HOWTO</a>
document.
<h2><a class="mozTocH2" name="mozTocId830340"></a>open() considerations</h2>
Various drivers have different characteristics when a device node is
opened. One problem with the ioctl system call is that a user only
needs read permissions to execute it but may, with the ioctls like
SG_IO, write to a device (e.g. format it).&nbsp; Command (operation
code) sniffing logic is used to overcome this security problem. Also
users of the SG_IO ioctl need to be aware when they "share" a device
with sd, st or a cdrom driver that state machines within those drivers
may be tricked. This may be unavoidable but the users of the SG_IO
ioctl should take appropriate care.<br>
<br>
Opening a file in linux with flags of zero implies the O_RDONLY flag
and hence read only access. All open() system calls can yield ENOENT
(no such file or directory); ENODEV (no such device) if the file exists
but there is no attached device and EACCES (permission denied) if the
user doesn't have appropriate permissions.<br>
<br>
A user with CAP_SYS_RAWIO capability (normally associated with the
"root" user) bypasses all command sniffing and other access controls
that would otherwise lead to EACCES or EPERM errors. With the sg driver
such a user may still need to open() a device node with O_RDWR (rather
than O_RDONLY) to use all SCSI commands.<br>
<br>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <caption><span style="font-weight: bold;">Table 2. open() flags for
SG_IO ioctl usage</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">open()
flags</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">sg<br>
notes<br>
      </span> </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">sd<br>
notes<br>
      </span> </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">st<br>
notes<br>
      </span> </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">cdrom<br>
notes<br>
      </span> </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Comments</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&lt;none&gt; or<br>
O_RDONLY<br>
      </td>
      <td style="vertical-align: top;">1, 2<br>
      </td>
      <td style="vertical-align: top;">3,4<br>
      </td>
      <td style="vertical-align: top;">3,5<br>
      </td>
      <td style="vertical-align: top;">3,6<br>
      </td>
      <td style="vertical-align: top;">best to add O_NONBLOCK. For a
device with removable media (e.g. tape drive) that depends on whether
the drive or its media is being accessed.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">O_RDONLY | O_NONBLOCK<br>
      </td>
      <td style="vertical-align: top;">1,7<br>
      </td>
      <td style="vertical-align: top;">3<br>
      </td>
      <td style="vertical-align: top;">3,13<br>
      </td>
      <td style="vertical-align: top;">3<br>
      </td>
      <td style="vertical-align: top;">recommended when SCSI commands
are recognized as reading information from the device<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">O_RDWR<br>
      </td>
      <td style="vertical-align: top;">2<br>
      </td>
      <td style="vertical-align: top;">4,8,9<br>
      </td>
      <td style="vertical-align: top;">5,8,9<br>
      </td>
      <td style="vertical-align: top;">6,8,9<br>
      </td>
      <td style="vertical-align: top;">again, could be better to add
O_NONBLOCK</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">O_RDWR | O_NONBLOCK<br>
      </td>
      <td style="vertical-align: top;">7<br>
      </td>
      <td style="vertical-align: top;">8,9<br>
      </td>
      <td style="vertical-align: top;">8,9,13<br>
      </td>
      <td style="vertical-align: top;">8,9<br>
      </td>
      <td style="vertical-align: top;">recommended when arbitrary
(including vendor specific) SCSI commands are to be sent<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&lt;&lt; interaction with
O_EXCL&gt;&gt;<br>
      </td>
      <td style="vertical-align: top;">10<br>
      </td>
      <td style="vertical-align: top;">11<br>
      </td>
      <td style="vertical-align: top;">12<br>
      </td>
      <td style="vertical-align: top;">11<br>
      </td>
      <td style="vertical-align: top;">only use when sure that no other
application may want to access the device (or partition). A surprising
number of applications do "poke around" devices.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&lt;&lt; interaction with
O_DIRECT&gt;&gt;<br>
      </td>
      <td style="vertical-align: top;">-<br>
      </td>
      <td style="vertical-align: top;">--&gt;<br>
      </td>
      <td style="vertical-align: top;">-<br>
      </td>
      <td style="vertical-align: top;">--&gt;<br>
      </td>
      <td style="vertical-align: top;">requires sector alignment on
data transfers (ignored by sg and st)<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<span style="font-weight: bold;">Notes</span>:<br>
<ol>
  <li>on subsequent SG_IO ioctl calls, the sg driver will only allow
SCSI commands in its allow_ops array, others result in EPERM (operation
not permitted) in errno. See <a href="#SCSI_command_permissions">below</a>
.<br>
  </li>
  <li>if previous open() of this sg device node still holds O_EXCL then
this open() waits until it clears.</li>
  <li>on subsequent SG_IO ioctl calls, the block layer will only allow
SCSI commands listed as "safe_for_read" in the verify_command()
function in the drivers/block/scsi_ioctl.c file; others result in EPERM
(operation not permitted) in errno. See <a
 href="#SCSI_command_permissions">below</a> .<br>
  </li>
  <li>if removable media and it is not present then yields ENOMEDIUM
(no medium found)</li>
  <li>if a tape is not present in drive then yields EIO (input/output
error), if tape is "in use" then yields EBUSY (resource busy). Only one
open file descriptor is allowed per st device node at a time (although
dup() can be used).<br>
  </li>
  <li>if tray closed and media is not present then yields ENOMEDIUM (no
medium found); if tray open then tries to close it and if no media
present then yields ENOMEDIUM</li>
  <li>if previous open() of this sg device node still holds O_EXCL then
yields EBUSY (resource busy).<br>
  </li>
  <li>on subsequent SG_IO ioctl calls, the block layer will allow SCSI
commands listed as either "safe_for_read" or "safe_for_write". For
other SCSI commands the user requires the CAP_SYS_RAWIO capability
(usually associated with the "root" user); if not yields EPERM
(operation
not permitted). The first instance of other SCSI commands since boot,
sends an annoying "scsi: unknown opcode" message to the log.<br>
  </li>
  <li>if the media or drive is marked as not writable then yields EROFS
(read-only file system).</li>
  <li>if sg device node already has exclusive lock then a subsequent
attempt to open(O_EXCL) will wait unless O_NONBLOCK is given in which
case it yields EBUSY (resource busy)<br>
  </li>
  <li>implemented at block device level (which knows about partitions
within devices). If a previous open(O_EXCL) is active then a subsequent
open(O_EXCL) yields EBUSY (resource busy). Mounted file systems
typically open a device/partition with O_EXCL; as long as an
application using the SG_IO ioctl does not also try and use the O_EXCL
flag then it will be allowed access to the device.</li>
  <li>the st driver does not support (i.e. ignores) the O_EXCL flag.
However the fact that it only permits one active open() per tape device
is similar functionality.<br>
  </li>
  <li>if tape is "in use" then yields EBUSY (resource busy). Only one
open file descriptor is allowed per st device node at a time.</li>
</ol>
The O_EXCL flag has a different effect in the sg driver and the block
layer. In the sg driver, once O_EXCL is held on a device, all
subsequent open() attempts will either wait or yield EBUSY
(irrespective of whether they attempt to use the O_EXCL flag). Once a
partition/device is opened successfully in the block layer (with the sd
or cdrom driver) only subsequent open() attempts that also use the
O_EXCL flag are rejected (with EBUSY). A O_EXCL lock held on a device
in the block layer has no effect on accessing the same device via the
sg driver (and vice versa).<br>
<br>
The first successful open on a sd or a cdrom device node that has
removable media will send a PREVENT ALLOW MEDIUM REMOVAL (prevent) SCSI
command to the device. If successful, this will inhibit a subsequent
START STOP UNIT (eject) SCSI command and de-activate the eject button
on the drive. In emergencies, the SG_IO ioctl can be used to defeat
this action, an example of this is the <a href="sdparm.html">sdparm</a>
utility, specifically "sdparm --command=unlock".<br>
<br>
The open() flag O_NDELAY has the same value and meaning as O_NONBLOCK.
Other flags such as O_DIRECT, O_TRUNC and O_APPEND have no effect on
the SG_IO ioctl.<br>
<h2><a class="mozTocH2" name="mozTocId645134"></a>SCSI command
permissions</h2>
In linux a user only needs read permissions on a file descriptor to
execute an ioctl() system command. In the case of the SG_IO ioctl, a
SCSI command could be sent that obviously changes the state of a device
(e.g. WRITE to a disk). So both implementations of the SG_IO ioctl
require more than read permissions for some commands, especially those
that are known to change the state of a device or those that have some
unknown action (e.g. vendor specific commands).<br>
<br>
Here is a table of SCSI commands that don't need the user to have write
permissions (or in some cases CAP_SYS_RAWIO capability which usually
equates to "root" user):<br>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <caption><span style="font-weight: bold;">Table 3. SCSI command
minimum permission requirements</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">SCSI
command</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">(draft)
standard</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">sg
driver requires</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">block
layer SG_IO<br>
requires (except st)</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Comments</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">BLANK<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">CLOSE TRACK/SESSION<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ERASE<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">FLUSH CACHE<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">Really SYNCHRONIZE CACHE command<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">FORMAT UNIT<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">default command timeout may not
be long enough<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">GET CONFIGURATION<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">reads CD/DVD metadata<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">GET EVENT STATUS NOTIFICATION<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">GET PERFORMANCE<br>
      </td>
      <td style="vertical-align: top;">MMC-4</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">INQUIRY<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY<br>
      </td>
      <td style="vertical-align: top;">All SCSI devices should respond
to this command<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">LOAD UNLOAD MEDIUM<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">MEDIUM may be replaced by CD,
DVD or nothing<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">LOG SELECT<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">used to change logging or clear
logged data<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">LOG SENSE<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">used to fetch logged data<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">MAINTENANCE COMMAND IN<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY<br>
      </td>
      <td style="vertical-align: top;">CAP_SYS_RAW_IO<br>
      <br>
      </td>
      <td style="vertical-align: top;">various "REPORT ..." commands
such as REPORT SUPPORTED OPERATION CODES in here<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">MODE SELECT (6+10)<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">Used to change SCSI device
metadata<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">MODE SENSE (6+10)<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY </td>
      <td style="vertical-align: top;">O_RDONLY </td>
      <td style="vertical-align: top;">Used to read SCSI device metadata<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PAUSE RESUME</td>
      <td style="vertical-align: top;">MMC-4</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PLAY AUDIO (10)<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PLAY AUDIO MSF<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PLAY AUDIO TI<br>
      </td>
      <td style="vertical-align: top;">??<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">opcode 0x48, unassigned to&nbsp;
any spec in SPC-4<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PLAY CD</td>
      <td style="vertical-align: top;">MMC-2<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">old, now SPARE IN in SPC-4<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">PREVENT ALLOW MEDIUM REMOVAL<br>
      </td>
      <td style="vertical-align: top;">SPC-4, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">sd, st and cdrom drivers use
this internally<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ (6+10+12+16)<br>
      </td>
      <td style="vertical-align: top;">SBC-3<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ BUFFER<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ BUFFER CAPACITY<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ CAPACITY(10)<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ CAPACITY(16)<br>
      </td>
      <td style="vertical-align: top;">SBC-3,<br>
MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY<br>
      </td>
      <td style="vertical-align: top;">CAP_SYS_RAW_IO<br>
      </td>
      <td style="vertical-align: top;">within SERVICE ACTION IN
command. Needed for RAIDs larger than 2 TB<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ CD<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ CD MSF<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ CDVD CAPACITY<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">Strange (old ?) name from
cdrom.h . Actually is READ CAPACITY.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ DEFECT (10)<br>
      </td>
      <td style="vertical-align: top;">SBC-3<br>
      </td>
      <td style="vertical-align: top;">O_RDWR<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ DISC INFO<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ DVD STRUCTURE<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ FORMAT CAPACITIES<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ HEADER<br>
      </td>
      <td style="vertical-align: top;">MMC-2<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ LONG (10)<br>
      </td>
      <td style="vertical-align: top;">SBC-3<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">but not READ LONG (16)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ SUB-CHANNEL<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ TOC/PMA/ATIP<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">READ TRACK (RZONE) INFO<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">In MMC-4 called READ TRACK INFO<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">RECEIVE DIAGNOSTIC<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">CAP_SYS_RAW_IO</td>
      <td style="vertical-align: top;">the SES command set uses this
command a lot. An SES device is only accessible via an sg device node<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">REPAIR (RZONE) TRACK<br>
      </td>
      <td style="vertical-align: top;">MMC-4</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">REPORT KEY<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">REPORT LUNS<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">CAP_SYS_RAW_IO</td>
      <td style="vertical-align: top;">mandatory since SPC-3<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">REQUEST SENSE<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">has uses other than those
displaced by autosense<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">RESERVE (RZONE) TRACK<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SCAN<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SEEK<br>
      </td>
      <td style="vertical-align: top;">MMC-4</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SEND CUE SHEET<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SEND DVD STRUCTURE<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">[SEND EVENT]<br>
      </td>
      <td style="vertical-align: top;">MMC-2<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">cdrom.h associates opcode 0xa2
but MMC-2 uses opcode 0x5d ??<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SEND KEY<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SEND OPC INFORMATION<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SERVICE ACTION IN<br>
      </td>
      <td style="vertical-align: top;">SPC-4, SBC-3<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">CAP_SYS_RAW_IO</td>
      <td style="vertical-align: top;">READ CAPACITY (16) service
action in here<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SET CD SPEED<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">cdrom.h calls this SET SPEED<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SET STREAMING<br>
      </td>
      <td style="vertical-align: top;">MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">START STOP UNIT<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">hmm<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">STOP PLAY/SCAN<br>
      </td>
      <td style="vertical-align: top;">MMC-4</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SYNCHRONIZE CACHE</td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">cdrom.h calls this FLUSH CACHE<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">TEST UNIT READY<br>
      </td>
      <td style="vertical-align: top;">SPC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">All SCSI devices should respond
to this command</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">VERIFY (10+16)<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">WRITE (6+10+12+16)</td>
      <td style="vertical-align: top;">SBC-3<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">WRITE LONG (10+16)<br>
      </td>
      <td style="vertical-align: top;">SBC-3<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">WRITE VERIFY (10+16)<br>
      </td>
      <td style="vertical-align: top;">SBC-3, MMC-4<br>
      </td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">O_RDWR</td>
      <td style="vertical-align: top;">only WRITE VERIFY(10) is in MMC-4<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
Any other SCSI command (opcode) not mentioned for the sg driver needs
O_RDWR. Any other SCSI command (opcode) not mentioned for the block
layer SG_IO ioctl needs a user with CAP_SYS_RAW_IO capability. All
"block" SG_IO ioctl calls on st device nodes need a user with
CAP_SYS_RAW_IO capability. If a
user does not have sufficient permissions to execute a SCSI command via
the SG_IO ioctl then the system calls fails (i.e. no SCSI command is
sent) and errno is set to EPERM (operation not permitted).<br>
<br>
Both the sg driver and the block layer SG_IO code use internal tables
to enforce the permissions shown in the above table (allow_ops and
cmd_type [safe_for_read and safe_for_write] respectively). This
technique doesn't scale well, since more advanced command sets (e.g.
OSD) use service actions (and one opcode: 0x7f in the case of OSD).
There may also be overlap in opcode usage between command sets, for
example between SBC, MMC and SSC.<br>
<h2><a class="mozTocH2" name="mozTocId154063"></a>Maximum transfer size
per command</h2>
The largest amount of data that can be transferred by a single SCSI
command is often a concern. Various SCSI command sets (e.g. SBC-3 for
disk
READs and WRITEs, SSC-3 for tape READs and WRITEs, and SPC-4 for
READ+WRITE BUFFER) allow very large
data transfer sizes but Linux is not so accommodating. The Host Bus
Adapter (HBA)
could have transfer size limits as could the transport and finally the
SCSI device
itself. In the latter case SBC-3 defines a "Block Limits" Vital Product
Data (VPD) while SSC has the READ BLOCK LIMITS SCSI command. SBC-3's
optional Block Limits VPD page contains both maximum and optimal
counts. In the author's opinion that latter distinction is very
important: the block susbsystem should try and use optimal sizes while
pass through users should only be constrained by maximum sizes. Also if
a pass through user exceeds a maximum transfer size imposed by a SCSI
device, then the device can report an error. There is an
underlying assumption that the applications using a pass through
interface know what they are doing, or at least know more than the
various kernel susbsystems. On the other hand, the kernel has the
responsibility to allocate critical shared resources such as memory.<br>
<br>
In the past, Linux used a single, "big-enough", block of memory for the
source or destination of large data transfers. Then scatter-gather
lists where added to break transfers up into smaller (often "page" size
(4 KB on i386 architecture)) chunks which made memory management easier
for the kernel. Now, in the lk 2.6 series, the single block of memory
option is being phased out. <br>
<br>
The Linux SCSI subsystem imposes a 128
element limit on scatter gather lists via its SCSI_MAX_PHYS_SEGMENTS
define. The way various memory pools are allocated by the linux SCSI
subsystem, SCSI_MAX_PHYS_SEGMENTS could be increased to 256. Associated
with each type of HBA there is normally a low level driver (LLD). Each
LLD can further limit the maximum number of elements with
the scsi_host_template::sg_tablesize field. Prior to lk 2.6.16 the sg
and
st drivers used the .sg_tablesize field only, since lk 2.6.16 those
drivers are also constrained by SCSI_MAX_PHYS_SEGMENTS. This leads to a
potential halving of the maximum transfer size. Many LLDs set the
.sg_tablesize field to SG_ALL (which is 255) but they may as well set
that field to 256 unless the HBA hardware has a constraint.<br>
<br>
User space
memory may be allocated as the source and/or destination for DMA
transfers from
the HBA (i.e. direct IO). Even if the user space allocated a large
amount of memory
with a single malloc(), the HBA DMA element typically has a different
view of
memory. This view may well contain many "page" size discontinuous
pieces. This has the
effect of using up, or perhaps exhausting, scatter-gather elements.<br>
<br>
The sg driver attempts to build scatter gather lists with each element
up to SG_SCATTER_SZ bytes large. This define is found in
include/scsi/sg.h
and has been set to 32 KB for some years. That is 8 times the page size
(of 4 KB) on the i386 architecture. Some users who need really
large transfers increase this define (and it is best to keep it a power
of 2). However since lk 2.6.16 another limit comes into play: the
MAX_SEGMENT_SIZE define which is set to 64 KB. MAX_SEGMENT_SIZE is a
default and can be overridden by the LLD calling
blk_queue_max_segment_size().<br>
<br>
In lk 2.6.16 two further LLD parameters
come into play even when the sg (and st) driver is used. These are
scsi_host_template::max_sectors and scsi_host_template::use_clustering
.&nbsp; <br>
<br>
The .max_sectors setting in the LLD is the maximum number of 512 byte
sectors allowed in a single SCSI command's scatter gather lists (for
data transfers). Yes, that is a strange limit when trying to send a
SCSI
WRITE BUFFER command to upload firmware. Sysfs makes the LLD's
.max_sectors setting visible (converted to kilobytes) in
/sys/block/sd&lt;x&gt;/queue/max_hw_sectors_kb . The maximum allowable
value in a LLD's .max_sector seems to be 65535 (0xffff in hexadecimal).
This limits the maximum transfer size to (32*1024*1024 - 512) bytes,
assuming other limitations have been overcome. [The 65535 sector limit
is because Scsi_Host::max_sectors has type "unsigned short". Hopefully
this type is expanded to "int" in the future (or removed).]<br>
<br>
The .use_clustering field should be set to ENABLE_CLUSTERING . If not,
the block subsystem rebuilds the scatter gather list it gets from the
sg driver with page size (e.g. 4 KB) elements. [Actually is does that
anyway, but
when ENABLE_CLUSTERING is set, it coalesces them again!]<br>
<br>
<h2><a class="mozTocH2" name="mozTocId267334"></a>Conclusion</h2>
In some situations, sending commands via the SG_IO ioctl may interfere
with a higher level driver's use of a device. Users of the SG_IO ioctl
should be aware that they are using a powerful, but low level facility,
and write code accordingly. An example of this would be a utility to
perform self tests on a disk: "background" self tests should be
preferred over "foreground" self tests if there is a chance the
computer may be using a file system on that disk at the time. Even a
short foreground self test may take up to two minutes which is a long
time to lock out a file system.<br>
<br>
<p>Return to <a href="index.html">main</a> page. </p>
<center>
<p>Last updated: 2nd Aprl 2006<br>
<br>
</p>
</center>
</body>
</html>
