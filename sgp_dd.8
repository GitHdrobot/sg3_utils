.TH SGP_DD "8" "October 2004" "sg3_utils-1.10" SG3_UTILS
.SH NAME
sgp_dd \- copies data to and from files and devices. Specialised for
devices that understand the SCSI command set.
.SH SYNOPSIS
.B sgp_dd
[\fIbpt=<n>\fR] [\fIbs=<n>\fR] [\fIcdbsz=6|10|12|16\fR] [\fIcoe=0|1\fR]
[\fIcount=<n>\fR] [\fIdeb=<n>\fR] [\fIdio=0|1\fR] [\fIfua=0|1|2|3\fR]
[\fIibs=<n>\fR] [\fIif=<ifile>\fR] [\fIobs=<n>\fR] [\fIof=<ofile>\fR]
[\fIseek=<n>\fR] [\fIskip=<n>\fR] [\fIsync=0|1\fR] [\fIthr=<n>\fR]
[\fItime=0|1\fR] [\fI--version\fR]
.SH DESCRIPTION
.\" Add any additional description here
.PP
Copy data to and from any files. Specialised for "files" that are
Linux SCSI generic (sg) and raw devices. Similar syntax and semantics to 
.B dd(1) 
but does not perform any conversions. Uses POSIX threads to increase
the amount of parallelism. This improves speed in some cases.
.TP
bpt=BLOCKS
each IO transaction will be made using this number of blocks (or less if 
near the end of count). Default is 128.
.TP
bs=BYTES
this 
.B must 
be the block size of the physical device. Note that this differs from
.B dd(1) 
which permits "bs" to be an integral multiple. Default is 512 which 
is usually correct for disks but incorrect for cdroms (which normally
have 2048 byte blocks).
cdbsz=6 | 10 | 12 | 16
size of SCSI READ and/or WRITE commands issued on sg device names.
Default is 10 byte SCSI command blocks
.TP
coe=0 | 1
continue on error is 0 (off) by default. When it is 1 read errors
are stepped over (with a block (or blocks) of zeroes being output).
When 1, write errors are ignored (and alignment is maintained)
Similar to "conv=noerror" in
.B dd(1)
utility. Default is 0 which implies stop on error
.TP
count=BLOCKS
copy this number of blocks from 'if' to 'of'. Default is the minimum (
of 'if' and 'of') number of blocks that sg devices return from READ
CAPACITY SCSI commands or that block devices (or their partitions) report.
Normal files are not probed for their size. If 'skip'
or 'seek' are given and the count is derived (i.e. not explicitly given)
then the derived count is scaled back so that the copy will not overrun the
device. If the file name is a block device partition and count is not given
then the size of the partition rather than the size of the whole device is
used. If count is not given and cannot be derived then an error message
is issued and no copy takes place.
.TP
deb=NUM
outputs debug information. If NUM is 0 (default) then none and as NUM
increases so does the amount of debug (max debug output when NUM is 9)
.TP
dio=0 | 1
default is 0 which selects indirect IO. Value of 1 attempts direct
IO which, if not available, falls back to indirect IO and notes this
at completion. If direct IO is selected and /proc/scsi/sg/allow_dio
has the value of 0 then a warning is issued (and indirect IO is performed)
.TP
fua=0 | 1 | 2 | 3
force unit access bit. When 3, fua is set on both "if" and "of", when 2, fua
is set on "if", when 1, fua is set on "of", when 0 (the default), fua is
cleared on both. 6 byte SCSI READ and WRITE commands (cdbsz=6) do not
support the fua bit. Only active for sg device file names.
.TP
ibs=BYTES
if given must be the same as bs
.TP
if=FILE
read from FILE instead of stdin. A file name of - is taken to be stdin.
Starts reading at the beginning of FILE unless "skip" is given.
.TP
obs=BYTES
if given must be the same as bs
.TP
of=FILE
write to FILE instead of stdout. A file name of - is taken to be stdout.
If FILE is /dev/null then no actual writes are performed. If FILE is .
(period) then it is treated the same way as /dev/null (this is a
shorthand notation)
.TP
seek=BLOCKS
start writing BLOCKS bs-sized blocks from the start of the output file.
Default is block 0 (i.e. start of file).
.TP
skip=BLOCKS
start reading BLOCKS bs-sized blocks from the start of input file.
Default is block 0 (i.e. start of file).
.TP
sync=0 | 1
when 1, does SYNCHRONIZE CACHE command on "of" at the end of the transfer.
Only active when "of" is a sg device file name
.TP
thr=NUM
this is the number or worker threads (default 4) that attempt to
copy in parallel. Minimum is 0 and maximum is 16
.TP
time=0 | 1
when 1, times transfer and does throughput calculation, outputting the
results (to stderr) at completion. When 0 (default) doesn't perform timing
.TP
--version
outputs version number information and exits
.PP
A raw device must be bound to a block device prior to using sgp_dd.
See
.B raw(8)
for more information about binding raw devices. To be safe, the sg device
mapping to SCSI block devices should be checked with "cat /proc/scsi/scsi"
before use.
.PP
Raw device partition information can often be found with
.B fdisk(8)
[the "-ul" argument is useful in this respect].
.PP
BYTES and BLOCKS may be followed by the following multiplicative suffixes:
c C *1; b B *512; k *1,024; K *1,000; m *1,048,576; M *1,000,000;
g *1,073,741,824; G *1,000,000,000; t *1,099,511,627,776 and
T *1,000,000,000,000 (the latter two can only be used for count, skip
and seek values).
.PP
Alternatively numerical values can be given in hexadecimal preceded by
either "0x" or "0X". When hex numbers are given multipliers cannot be
used.
.PP
The count, skip and seek parameters can take 64 bit values (i.e. very
big numbers). Other values are limited to what can fit in a signed
32 bit number.
.PP
Data usually gets to the user space in a 2 stage process: first the
SCSI adapter DMAs into kernel buffers and then the sg driver copies
this data into user memory (write operations reverse this sequence).
This is called "indirect IO" and there is a "dio" option to select
"direct IO" which will DMA directly into user memory. Due to some
issues "direct IO" is disabled in the sg driver and needs a
configuration change to activate it.
.PP
All informative, warning and error output is sent to stderr so that
dd's output file can be stdout and remain unpolluted. If no options
are given, then the usage message is output and nothing else happens.
.PP
Why use sgp_dd? Because in some cases it is twice as fast as dd
(mainly with sg devices, raw devices give some improvement).
Another reason is that big copies fill the block device caches
which has a negative impact on other machine activity.
.SH EXAMPLES
.PP
Looks quite similar in usage to dd:
.PP
   sgp_dd if=/dev/sg0 of=t bs=512 count=1M
.PP
This will copy 1 million 512 byte blocks from the device associated with
/dev/sg0 (which should have 512 byte blocks) to a file called t.
Assuming /dev/sda and /dev/sg0 are the same device then the above is
equivalent to:
.PP
   dd if=/dev/sda of=t bs=512 count=1000000
.PP
although dd's speed may improve if bs was larger and count was suitably
reduced. Using a raw device to do something similar on a IDE disk:
.PP
   raw /dev/raw/raw1 /dev/hda
.br
   sgp_dd if=/dev/raw/raw1 of=t bs=512 count=1M
.PP
To copy a SCSI disk partition to an IDE disk partition:
.PP
   raw /dev/raw/raw2 /dev/hda3
.br
   sgp_dd if=/dev/sg0 skip=10123456 of=/dev/raw/raw2 bs=512
.PP
This assumes a valid partition is found on the SCSI disk at the given
skip block address (past the 5 GB point of that disk) and that
the partition goes to the end of the SCSI disk. An explicit count
is probably a safer option.
.PP
To do a fast copy from one SCSI disk to another one with similar
geometry (stepping over errors on the source disk):
.PP
   sgp_dd if=/dev/sg0 of=/dev/sg1 bs=512 coe=1
.SH AUTHORS
Written by Doug Gilbert and Peter Allworth.
.SH "REPORTING BUGS"
Report bugs to <dgilbert at interlog dot com>.
.SH COPYRIGHT
Copyright \(co 2000-2004 Douglas Gilbert
.br
This software is distributed under the GPL version 2. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.SH "SEE ALSO"
A simpler, non-threaded version of this utility called
.B sg_dd
is in the sg3_utils package. The lmbench package contains
.B lmdd
which is also interesting.
.B raw(8), dd(1)
